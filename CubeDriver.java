
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/**
 * Driver class: Build, traverse, print linkage
 */
public class CubeDriver {
	public static void main(String[] args) {
		
		// How many nodes per side
		int sideNodes = 3;
		
		Cube cube = new Cube();
		cube.build(cube.generateCubeGraph(sideNodes));
		
		System.out.println("Node execution order: ");
		cube.BFT();
		
		System.out.println("Nodes links:");
		dcube.printAL();
		
		System.out.println("Nodes on Layers:");
		cube.printLayers(sideNodes);
	}
}

/**
 * Cube creator
 */
class Cube{
	
	// Adjacency list (Hold node's neighbors)
	int al[][];
	
	// Degree array (Count how many neighbor per node)
	int dl[];
	
	int NODES;
	int EDGES;
	int MAX_LINKS = 6; // No node can have more than 6 links in all case
	
	/**
	 * Create the links between nodes based on the input generated by generateCubeGraph() mehtod
	 */
	public void build(String input){
		Scanner scan = new Scanner(input);
		
		// Get #Nodes and #Edges
		NODES = scan.nextInt();
		EDGES = scan.nextInt();
		
		// Initialize 2D Array and Degree array
		al = new int[NODES][MAX_LINKS];
		dl = new int[NODES];
		
		// Store the link between nodes
		for(int i=0; i<EDGES; i++){
			int node1, node2;
			
			node1  = scan.nextInt();
			node2 = scan.nextInt();
			
			int node1Neighbors = dl[node1]++;
			int node2Neighbors = dl[node2]++;
			
			al[node1][node1Neighbors] = node2;
			al[node2][node2Neighbors] = node1;
		}
		
	}
	
	/**
	 * Traverse using Breadth first traversal method
	 * Plug the middle node in a queue, then poll it and put it's neighbor, then poll each neighbor and put their neighbors if not visited already
	 */
	public void BFT(){
		int visited[] = new int[NODES];
		Queue<Integer> q = new LinkedList<Integer>();
		int VISITED = 1;
		
		// Plug the center node
		int middle = NODES/2;
		q.offer(middle);
		visited[middle] = VISITED;
		
		while(!q.isEmpty()){
			int polledNode = q.poll();
			System.out.print(polledNode + " ");
			
			for(int i=0; i < dl[polledNode]; i++){
				int neighbor = al[polledNode][i];
				
				if(visited[neighbor] != VISITED){
					q.offer(neighbor);
					visited[neighbor] = VISITED;
				}
			}
		}
		System.out.println("\n");
	}
	
	/**
	 * Input generator for a cube
	 */
	public String generateCubeGraph(int n){
		int SIDE = n; // Number of nodes in one side of the cube
		String links = ""; // Holds the final output
		int link = 0; // Counts the number of links
		
		for(int row=0; row<SIDE; row++){
			for(int col=0; col<SIDE; col++){
				for(int depth=0; depth<SIDE; depth++){
					int current = depth + (col * SIDE) + (row * SIDE * SIDE);
					
					// If not last depth
					if(depth != SIDE-1){
						links += String.format("%d %d\n", current, current+1);
						link++;
					}
						
					// If not last col
					if(col != SIDE-1){
						links += String.format("%d %d\n", current, current+SIDE);
						link++;
					}
					
					// If not last row
					if(row != SIDE-1){
						links += String.format("%d %d\n", current, current+(SIDE*SIDE));
						link++;
					}
				}
			}
		}
		
		// return #Nodes, #Edges, links ...
		return String.format("%d %d\n%s", SIDE*SIDE*SIDE, link, links);
	}
	
	/**
	 * Prints the links between each nodes. Used for debugging only
	 */
	public void printAL(){
		for(int node = 0; node < NODES; node++){
			System.out.print(String.format("Node %3d linked to nodes: ", node));
			for(int neighbor = 0; neighbor < dl[node]; neighbor++){
				System.out.print(String.format("%3d ", al[node][neighbor]));
			}
			System.out.println();
		}
		System.out.println();
	}
	
	/**
	 * Print 3D layers nodes number
	 * */
	public void printLayers(int sideNode){
		for(int layer=0; layer<sideNode; layer++){
			System.out.println("Layer: " + layer);
			for(int row = 0; row < sideNode; row++){
				for(int col = 0; col < sideNode; col++){
					int current = layer + (col * sideNode) + (row * sideNode * sideNode);
					System.out.print(String.format("%3d ", current));
				}
				System.out.println();
			}
			System.out.println();
		}
	}
}
